# Version 3 Requirements: UCI Maturity and Engine Strength Foundation

This document reconstructs the major-version 3 requirements from the delivered
implementation work.

## Goal

Ship a stable, playable UCI chess engine with:

- practical GUI compatibility (PyChess-friendly),
- progressively stronger engine levels,
- documented optimization and UCI enhancement history,
- release-ready build/distribution workflow.

## Engine and Search Requirements

1. Maintain a clear engine interface (`Engine` trait) so strategy
implementations remain swappable.
2. Provide baseline diagnostic engines:
- random move engine,
- greedy capture-first engine.
3. Provide iterative deepening alpha-beta engine family with modular scoring.
4. Add practical search improvements across iterative versions, including:
- move ordering heuristics,
- pruning/reduction heuristics,
- TT integration/refinement,
- quiescence and SEE tuning,
- endgame conversion heuristics.
5. Introduce checkmate-aware behavior (avoid pure material-only play).
6. Add versioned iterative engine progression and preserve documentation of each
major optimization step.
7. Consolidate historical iterative variants into a final stable iterative
engine (`v16`) before the v4 threading phase.

## Evaluation Requirements

1. Support modular board-scoring interfaces.
2. Include material-based scoring baselines.
3. Add alternative metrics:
- AlphaZero-style material values,
- AlphaZero+legal-move activity variant.
4. Incorporate endgame-focused terms to improve conversion and reduce
draw-drift while clearly winning.

## Data and Utility Requirements

1. Full FEN support:
- parse FEN to `GameState`,
- generate FEN from `GameState`,
- parser/generator loopback tests.
2. Long algebraic conversion utilities:
- square <-> bitboard index helpers,
- move description <-> long algebraic helpers.
3. PGN support for game-state/history serialization and parsing.
4. Opening-book support from precomputed tables.
5. Test harnesses for engine-vs-engine matches and series statistics,
including color randomization and move-time statistics.

## UCI Requirements

1. Provide robust UCI command loop and startup handshake:
- `uci`, `isready`, `position`, `go`, `stop`, `quit`.
2. Support broad `setoption` surface expected by practical GUIs.
3. Maintain responsive behavior under GUI feature probing and startup.
4. Support key go modes and constraints:
- depth/movetime/nodes/mate,
- infinite/ponder flows,
- searchmoves enforcement.
5. Emit analysis info streams:
- PV, MultiPV, currline, refutations, WDL, mate-normalized reporting.
6. Support configurable strength controls and mapping.
7. Preserve compatibility behaviors for less-common UCI options.

## Time Management Requirements

1. Implement default move-budget policy from remaining time.
2. Support iterative tuning of time-allocation fraction.
3. Add improved adaptive strategy while keeping deterministic override controls.
4. Keep strategy configurable through UCI options.

## Testing and Benchmarking Requirements

1. Maintain perft validation capability (with option to disable expensive suites
during normal iteration).
2. Provide benchmark tooling (criterion or equivalent) for repeatable performance
tracking.
3. Add targeted unit/integration coverage for:
- move generation and application,
- UCI behavior,
- engine outputs and mapping correctness.

## Documentation Requirements

1. Add architecture documentation (`docs/code_structure.md`).
2. Add optimization narrative and theory guide (`docs/optimization.md`).
3. Add UCI enhancement guide (`docs/uci_enhancement.md`).
4. Keep code references and diagrams synchronized with real module structure.

## Release and Distribution Requirements

1. Add CI workflows for cross-platform builds (Linux/Windows/macOS).
2. Use version from Cargo metadata in artifact naming.
3. Support tag-driven release creation and asset publishing.
4. Ensure workflow robustness across OS-specific file-copy/build differences.
5. Document end-user download/install flow in README.

## Completion Criteria (Version 3)

Version 3 is considered complete when:

1. The engine is reliably playable via UCI GUI.
2. UCI option/go behavior is stable under practical GUI use.
3. Iterative engine stack reaches a consolidated stable endpoint (`v16`).
4. Core docs and release workflows are in place and usable.
